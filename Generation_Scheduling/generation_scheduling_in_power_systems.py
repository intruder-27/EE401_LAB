'''
EE401 LAB_WORK

ADITYA AGRAWAL - 20085114
VIBHOR GOEL - 20085108
'''

import time

tic_time = time.process_time()
import numpy as np
import matplotlib.pyplot as plt

# Loading input data from file
data_matrix = np.loadtxt("data.txt", dtype=float)
print(data_matrix)

'''
    N_units = total number of units
    p_upper_limit[i] = upper power generation limit of ith unit
    p_lower_limit[i] = lower power generation limit of ith unit
    cost_coeff_a[i], cost_coeff_b[i], cost_coeff_c[i] are coefficients of the production cost equation cost = a*x^2 + b^x + c 
'''

# Extracting data
cost_coeff_a = data_matrix[:, 0]
cost_coeff_b = data_matrix[:, 1]
cost_coeff_c = data_matrix[:, 2]
p_upper_limit = data_matrix[:, 3]
p_lower_limit = data_matrix[:, 4]
N_units = len(cost_coeff_a)

# Converting upper and lower limits of unit operation into integer datatype
p_upper_limit = p_upper_limit.astype(int)
p_lower_limit = p_lower_limit.astype(int)

# Validating input data
print(cost_coeff_a.shape, cost_coeff_b.shape, cost_coeff_c.shape)
print(p_lower_limit)
print(p_upper_limit)

'''
    p_max_gen = maximum generation possible (all units operating at their upper limits p_upper_limit)
    p_min_gen = minimum generation possible (the unit with the minimum lower limit operating)
'''
p_max_gen = int(np.sum(p_upper_limit))
p_min_gen = int(np.min(p_lower_limit))

print(p_min_gen, p_max_gen)


# Function to calculate cost in ($/hr) for the ith unit
def calculate_cost(unit_index, generation_requirement):
    """
    :param unit_index: Index of the ith unit
    :param generation_requirement: Generation requirement 'x'
    :return: Cost of generating 'x' from the ith unit in dollars per hour
    """
    if generation_requirement == 0:
        return 0
    if p_upper_limit[unit_index] >= generation_requirement >= p_lower_limit[unit_index]:
        return cost_coeff_a[unit_index] * generation_requirement * generation_requirement + cost_coeff_b[unit_index] * generation_requirement + cost_coeff_c[unit_index]
    return np.inf


# Testing the cost calculation function
print(calculate_cost(0, 10))

'''
    unit_costs[i][x]: Cost of generation 'x' from the ith unit
'''
# Calculating the cost ($/hr) for each unit and storing it in unit_costs
unit_costs = list()
for i in range(0, N_units):
    unit_i = list()
    for j in range(0, p_max_gen + 1):
        unit_i.append(calculate_cost(i, j))
    unit_costs.append(unit_i)

# Converting the list data type to a numpy array for computational efficiency
unit_costs = np.array(unit_costs)

print(unit_costs.shape)

print(unit_costs[:, p_min_gen:])


def plot_unit_costs():
    """
    :return: Plot of cost vs load for all units
    """
    # Fixing the size of the figure
    plt.figure(figsize=(10, 6))

    # Plotting the line points
    for i in range(0, N_units):
        plt.plot(np.arange(p_min_gen, p_max_gen + 1), unit_costs[i][p_min_gen:], label="unit" + str(i))

    # Labeling the axes
    plt.xlabel('megawatts')
    plt.ylabel('cost')

    # Giving a title to the graph
    plt.title('Cost vs load')

    # Show a legend on the plot
    plt.legend()

    # Function to show the plot
    plt.show()


# Plotting unit costs vs load
plot_unit_costs()

"""
    Setting up memory blocks for Dynamic programming
    f: 2D array of size (N_units + 1, max_load + 1) for storing minimum cost.
    unit_commitment: 3D array of size (N_units + 1, max_load + 1, N_units + 1) for storing unit 
        commitment along with power generated by each unit for 
        a generation requirement. 

"""
# f[i][j]: Minimum cost for generating 'j' MW by using the first 'i' units
f = np.full((N_units + 1, int(p_max_gen) + 1), np.inf, dtype=float)

'''
    Note: unit_costs[i][j] has zero-based indexing but 'f' has one-based indexing.
    => f[1,:] = unit_costs[0,:]
'''
# f[1][j] = calculate_cost(0, j), since it is the only unit working
f[1, :] = unit_costs[0, :]

# f[i][0] = 0 since all units are off
f[:, 0] = 0

'''
    We define the unit commitment 3D array for memoization.
    unit_commitment[i][x][j]: Number of units produced by 'jth' unit when the first 'i' units are used 
                 to produce 'x' MW of power 
                 OR we can say,
                 Number of units produced by the 'jth' unit in f[i][x]
'''
# Unit commitment declaration
unit_commitment = np.zeros((N_units + 1, p_max_gen + 1, N_units + 1))

# Initializing the unit commitment 3D array for producing 'x' MW using the 1st unit.
for x in range(p_lower_limit[0], p_upper_limit[0] + 1):
    unit_commitment[1][x][1] = x
print(unit_commitment.shape, f.shape)

'''
    Dynamic Programming loop
'''
# Traversing all the units from 1 to N_units
for i in range(1, N_units + 1):

    # Traversing the range of generation requirement
    for x in range(p_min_gen, p_max_gen + 1):
        if f[i][x] > f[i - 1][x]:
            f[i][x] = f[i - 1][x]
            unit_commitment[i][x] = unit_commitment[i - 1][x]

        # Determining the best value 'ith' unit should take for minimum cost.
        for y in range(0, x + 1):
            f_i_x = calculate_cost(i - 1, y) + f[i - 1][x - y]
            if f_i_x < f[i][x]:
                f[i][x] = f_i_x
                unit_commitment[i][x] = unit_commitment[i - 1][x - y]
                unit_commitment[i][x][i] = unit_commitment[i][x][i] + y

# Validating the total generation 'x' with total unit commitment
print(np.sum(unit_commitment[N_units][p_max_gen]), p_max_gen)


def plot_unit_commitment(generation_req):
    """
    :param generation_req: Generation requirement 'x'
    :return: Plot of unit commitment
    """
    # Fixing the size of the figure
    plt.figure(figsize=(10, 6))

    # Plotting the bar chart
    fig, ax = plt.subplots()
    p1 = ax.bar(np.arange(1, N_units + 1), unit_commitment[N_units][generation_req][1:N_units + 1])

    # Creating text to display
    text_str = ('Total power(MW) =' + str(np.sum(unit_commitment[N_units][generation_req][1:N_units + 1])) + '\n'
                + 'Total cost ($/HR) =' + str(round(f[N_units][generation_req], 2)))
    properties = dict(boxstyle='round', facecolor='wheat', alpha=0.5)

    # Labeling the axes
    plt.xlabel('units')
    plt.ylabel('megawatts')
    ax.set_xticks(np.arange(1, N_units + 1))
    ax.text(0.50, 0.95, text_str, transform=ax.transAxes,
            verticalalignment='top', ha='left', bbox=properties)

    # Giving a title to the graph
    plt.title('Unit Commitment')

    # Function to show the plot
    plt.show()


# Plotting unit commitment for different generation requirements
for generation_req in range(p_min_gen, p_max_gen + 1, (p_max_gen - p_min_gen) // 10):
    plot_unit_commitment(generation_req)

"""
    Comparing economic dispatch with single unit generations
"""

# Calculating cost for each unit 'i' without power limits
unit_costs_unbounded = list()

for i in range(0, N_units):
    unit_i_cost = list()
    for j in range(0, p_max_gen + 1):
        unit_i_cost.append(cost_coeff_a[i] * j * j + cost_coeff_b[i] * j + cost_coeff_c[i])
    unit_costs_unbounded.append(unit_i_cost)

unit_costs_unbounded = np.array(unit_costs_unbounded)
print(unit_costs_unbounded.shape)


def plot_economic_dispatch():
    """
    :return: Comparison plot of cost vs load for economic dispatch
    """
    # Fixing the size of the figure
    plt.figure(figsize=(10, 6))

    # Plotting the line points
    plt.plot(np.arange(p_max_gen + 1), f[N_units], label="Economic Dispatch")
    for i in range(0, N_units):
        plt.plot(np.arange(int(p_max_gen) + 1), unit_costs_unbounded[i], label="unit" + str(i))

    # Labeling the axes
    plt.xlabel('megawatts')
    plt.ylabel('cost')

    # Giving a title to the graph
    plt.title('Cost vs load')

    # Show a legend on the plot
    plt.legend()

    # Function to show the plot
    plt.show()


# Plotting Economic Dispatch
plot_economic_dispatch()
toc_time = time.process_time()

print("Time Elapsed = ", toc_time - tic_time)
